var MongoClient = require('mongodb').MongoClient;

/**
 * Default options
 */

var defaultOptions = {					
						mongodb_connection_url : 'mongodb://localhost:27017/test',
						collection: 'sessions', 
						mongoclient_connect_options : {}
					 };

					 
module.exports = function(connect) {
  var Store = connect.session.Store;  

  function MongoSessionStore(options) {
	this.options = defaultOptions;
	for(var k in options){
		this.options[k] = options[k];
	}	
    
	this.ttl();
	
    Store.call(this, this.options);      
  };
  
   MongoSessionStore.prototype.ttl = function(){
	var self = this;
	MongoClient.connect(self.options.mongodb_connection_url, self.options.mongoclient_connect_options, function(err, db) {
		db.collection(self.options.collection).ensureIndex({expires: 1}, {expireAfterSeconds: 0}, function(err, result) {
			db.close();
		});
	});	
   }
  
  /**
   * Inherit from `Store`.
   */

  MongoSessionStore.prototype.__proto__ = Store.prototype;
  
  /**
   * Attempt to fetch session by the given `sid`.
   *
   * @param {String} sid
   * @param {Function} callback
   * @api public
   */
  
  MongoSessionStore.prototype.get = function(sid, callback) {
    var self = this;
	process.nextTick(function(){
		MongoClient.connect(self.options.mongodb_connection_url, self.options.mongoclient_connect_options, function(err, db) {
			if(err){
				callback && callback(err);
			}
			else{
				db.collection(self.options.collection).findOne({_id: sid}, {}, function(err, session) {
					db.close();
					
					if (err) {
						callback && callback(err, null);
					} 
					else{
						if (session) {
						  if (!session.expires || new Date < session.expires) {
							callback(null, JSON.parse(session.session));
						  } 
						  else {
							self.destroy(sid, callback);
						  }
						} 
						else {
						  callback && callback();
						}					
					}
				});
			}
		});    
	});	
  };
  
    /**
   * Commit the given `sess` object associated with the given `sid`.
   *
   * @param {String} sid
   * @param {Session} sess
   * @param {Function} callback
   * @api public
   */

  MongoSessionStore.prototype.set = function(sid, session, callback) {
	var self = this;
	process.nextTick(function(){
		var s = {_id: sid, session: JSON.stringify(session)};

		if (session && session.cookie && session.cookie._expires) {
			s.expires = new Date(session.cookie._expires);
		}
		
		if(! s.expires){
			var today = new Date(),
			twoWeeks = 1000 * 60 * 60 * 24 * 14;
			s.expires = new Date(today.getTime() + twoWeeks);
		}          
		
		MongoClient.connect(self.options.mongodb_connection_url, self.options.mongoclient_connect_options, function(err, db) {
			if(err){
				callback && callback(err);
			}
			else{				
				db.collection(self.options.collection).update({_id: sid}, s, {upsert: true, w: 1}, function(err, data) {
					db.close();
					
					if (err) {
						callback && callback(err);
					}
					else {
						callback && callback(null);
					}
				});
			}
		});
	});
  };
  
  /**
   * Destroy the session associated with the given `sid`.
   *
   * @param {String} sid
   * @param {Function} callback
   * @api public
   */

  MongoSessionStore.prototype.destroy = function(sid, callback) {
	var self = this;
	process.nextTick(function(){
		MongoClient.connect(self.options.mongodb_connection_url, self.options.mongoclient_connect_options, function(err, db) {
			if(err){
				callback && callback(err);
			}
			else{
				db.collection(self.options.collection).remove({_id: sid}, {w:1}, function(err, numberOfRemovedDocs) {
					db.close();
					
					if (err) {
						callback && callback(err);
					}
					else {
						callback && callback(null);
					}
				});
			}
		}); 
	});
  };
  
   /**
   * Clear all sessions.
   *
   * @param {Function} callback
   * @api public
   */

  MongoSessionStore.prototype.clear = function(callback) {
	var self = this;
	process.nextTick(function(){
		MongoClient.connect(self.options.mongodb_connection_url, self.options.mongoclient_connect_options, function(err, db) {
			if(err){
				callback && callback(err);
			}
			else{
				db.collection(self.options.collection).drop(function(err, reply) {
					db.close();
					
					if (err) {
						callback && callback(err);
					}
					else {
						callback && callback(null);
					}
				});
			}
		}); 
	});
  };
  
  /**
   * Fetch number of sessions.
   *
   * @param {Function} callback
   * @api public
   */

  MongoSessionStore.prototype.length = function(callback) {
	var self = this;
	process.nextTick(function(){
		MongoClient.connect(self.options.mongodb_connection_url, self.options.mongoclient_connect_options, function(err, db) {
			if(err){
				callback && callback(err);
			}
			else{
				db.collection(self.options.collection).count(function(err, count) {
					db.close();
					
					if (err) {
						callback && callback(err);
					}
					else {
						callback && callback(null, count);
					}
				});
			}
		});  
	});
  };
 
  return MongoSessionStore;
};
